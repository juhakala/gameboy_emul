#include "z80.h"
#include "define.h"

void	no_boot(t_mem *mem)
{
	R_A = 0x01;
	R_F = 0xb0;
	R_BC = 0x0013;
	R_DE = 0x00d8;
	R_HL = 0x014d;
	R_SP = 0xfffe;
	R_TIMA = 0x0; //tima
	R_TMA = 0x0; //tma
	R_TAC = 0x0; //tac
	R_NR10 = 0x80; //nr10
	R_NR11 = 0xbf; //nr11
	R_NR12 = 0xf3; //nr12
	R_NR14 = 0xbf; //nr14
	R_NR21 = 0x3f; //nr21
	R_NR22 = 0x0; //nr22
	R_NR24 = 0xbf; //nr24
	R_NR30 = 0x7f; //nr30
	R_NR31 = 0xff; //nr31
	R_NR32 = 0x9f; //nr32
	R_NR33 = 0xbf; //nr33
	R_NR41 = 0xff; //nr41
	R_NR42 = 0x00; //nr42
	R_NR43 = 0x0; //nr43
	R_NR44 = 0xbf; //nr44
	R_NR50 = 0x77; //nr50
	R_NR51 = 0xf3; //nr51
	R_NR52 = 0xf1; //nr52
	R_LCDC = 0x91; //LCDC
	R_SCY = 0x0; //SCY
	R_SCX = 0x0; //SCX
	R_LYC = 0x0; //LYC
	R_BGP = 0xfc; //BGP
	R_OBP0 = 0xff; //OBP0
	R_OBP1 = 0xff; //OBP1
	R_WY = 0x0; //WY
	R_WX = 0x0; //WX
	R_IE = 0x0; //IE
	BOOT = 1; //no boot
	PC = 0x100;
}

void	get_boot(t_mem *mem)
{
	//0x35 from 0xb8 to 0xbf
	unsigned char boot[256] = {0x31, 0xfe, 0xff, 0xaf, 0x21, 0xff, 0x9f, 0x32, 0xcb, 0x7c, 0x20, 0xfb, 0x21, 0x26, 0xff, 0x0e,
							   0x11, 0x3e, 0x80, 0x32, 0xe2, 0x0c, 0x3e, 0xf3, 0xe2, 0x32, 0x3e, 0x77, 0x77, 0x3e, 0xfc, 0xe0,
							   0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1a, 0xcd, 0x95, 0x00, 0xcd, 0x96, 0x00, 0x13, 0x7b,
							   0xfe, 0x34, 0x20, 0xf3, 0x11, 0xd8, 0x00, 0x06, 0x08, 0x1a, 0x13, 0x22, 0x23, 0x05, 0x20, 0xf9,
							   0x3e, 0x19, 0xea, 0x10, 0x99, 0x21, 0x2f, 0x99, 0x0e, 0x0c, 0x3d, 0x28, 0x08, 0x32, 0x0d, 0x20,
							   0xf9, 0x2e, 0x0f, 0x18, 0xf3, 0x67, 0x3e, 0x64, 0x57, 0xe0, 0x42, 0x3e, 0x91, 0xe0, 0x40, 0x04,
							   0x1e, 0x02, 0x0e, 0x0c, 0xf0, 0x44, 0xfe, 0x90, 0x20, 0xfa, 0x0d, 0x20, 0xf7, 0x1d, 0x20, 0xf2,
							   0x0e, 0x13, 0x24, 0x7c, 0x1e, 0x83, 0xfe, 0x62, 0x28, 0x06, 0x1e, 0xc1, 0xfe, 0x64, 0x20, 0x06,
							   0x7b, 0xe2, 0x0c, 0x3e, 0x87, 0xe2, 0xf0, 0x42, 0x90, 0xe0, 0x42, 0x15, 0x20, 0xd2, 0x05, 0x20,
							   0x4f, 0x16, 0x20, 0x18, 0xcb, 0x4f, 0x06, 0x04, 0xc5, 0xcb, 0x11, 0x17, 0xc1, 0xcb, 0x11, 0x17,
							   0x05, 0x20, 0xf5, 0x22, 0x23, 0x22, 0x23, 0xc9, 0xce, 0xed, 0x66, 0x66, 0xcc, 0x0d, 0x00, 0x0b,
							   0x03, 0x73, 0x00, 0x83, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x08, 0x11, 0x1f, 0x88, 0x89, 0x00, 0x0e,
							   0xdc, 0xcc, 0x6e, 0xe6, 0xdd, 0xdd, 0xd9, 0x99, 0xbb, 0xbb, 0x67, 0x63, 0x6e, 0x0e, 0xec, 0xcc,
							   0xdd, 0xdc, 0x99, 0x9f, 0xbb, 0xb9, 0x33, 0x3e, 0x3c, 0x42, 0xb9, 0xa5, 0xb9, 0xa5, 0x42, 0x3c,
							   0x21, 0x04, 0x01, 0x11, 0xa8, 0x00, 0x1a, 0x13, 0xbe, 0x20, 0xfe, 0x23, 0x7d, 0xfe, 0x34, 0x20,
							   0xf5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xfb, 0x86, 0x20, 0xfe, 0x3e, 0x01, 0xe0, 0x50};
	mem->boot = (unsigned char*)malloc(sizeof(unsigned char) * 256);
	memcpy(mem->boot, boot, 256);
	PC = 0;
	BOOT = 0;
}

int		fetch_save(t_mem *mem)
{
	FILE *fp;
	char save[260];

	sprintf(save, "pokemone_save_size_%d", mem->memory->ram_size);
	mem->ram = (unsigned char*)malloc(sizeof(unsigned char) * mem->memory->ram_size);
	fp = fopen(save, "r");
	if (fp)
	{
		fread(mem->ram, 1, mem->memory->ram_size, fp);
		fclose(fp);
	}
	return (0);
}

int		get_header_info(t_mem *mem)
{
	if (mem->header->cart_type > 31 || mem->header->rom_size > 6 || mem->header->ram_size > 4)
		return (1);
	int mbc_arr[32] = {0, 1, 1, 1,-1, 2, 2,-1, 0, 0,-1, 0, 0, 0,-1, 3,
					   3, 3, 3, 3,-1,-1,-1,-1,-1, 5, 5, 5, 5, 5, 5, 0};
	mem->memory->mbc = mbc_arr[mem->header->cart_type];
	int rom_banks_arr[7] = {2, 4, 8, 16, 32, 64, 128};
	mem->memory->rom_banks = rom_banks_arr[mem->header->rom_size];
	int ram_banks_arr[5] = {0, 1, 1, 4, 16};
	mem->memory->cram_banks = ram_banks_arr[mem->header->ram_size];
	int ram_size_arr[6] = {0, 2048, 8192, 32768, 131072, 65536};
	mem->memory->cram_size = ram_size_arr[mem->header->ram_size];
	return (0);
}

int		read_to_mem(char **av, t_mem *mem)
{
	FILE *fp;
	size_t size;
	
	if (!(fp = fopen(av[1], "r")))
		return (1);
	fseek(fp, 0, SEEK_END);
	size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	mem->rom = (unsigned char*)malloc(sizeof(unsigned char) * size);
	fread(mem->rom, 1, size, fp);
	mem->memory->rom_size = size;
	memcpy(mem->header, &(*(mem->rom + 0x104)), 76);
	fclose(fp);
	return (0);
}

void	defaults(t_mem *mem)
{
	mem->halt = 0;
	mem->ime = 1;
	mem->memory->lcd_mode = 0;
	mem->memory->rom_bank = 1;
	mem->memory->cram_bank = 1;
	mem->memory->wram_bank = 1;
	mem->memory->vram_bank = 0;
	mem->memory->cram_enable = 0;
	mem->memory->cram_mode = 0;
	mem->reg->f = 0;

	R_LY = 0;
	R_SCX = 0;
	mem->memory->lcd_mode = 0;
	mem->timer->cpu_count = 0;
	mem->timer->lcd_count = 0;
	mem->timer->div_count = 0;
	mem->timer->tima_count = 0;
	mem->timer->tac_enable = 0;
	mem->timer->tac_rate = 0;
	int i;
	for (i = 0; i < 0x8000; i++)
		mem->vram[i] = 0;
	for (i = 0; i < 0x8000; i++)
		mem->wram[i] = 0;
	for (i = 0; i < 0x2000; i++)
		mem->rest_ram[i] = 0;
}

t_mem	*initial_setup(int ac, char **av)
{
	t_mem *mem;

	mem = (t_mem*)malloc(sizeof(t_mem));
	mem->reg = (t_reg*)malloc(sizeof(t_reg));
//	mem->io_reg = (t_io_reg*)malloc(sizeof(t_io_reg));
	mem->header = (t_header*)malloc(sizeof(t_header));
	mem->memory = (t_mem_control*)malloc(sizeof(t_mem_control));
	mem->timer = (t_timer*)malloc(sizeof(t_timer));
	mem->sdl = (t_sdl*)malloc(sizeof(t_sdl));
	if (ac > 1 && read_to_mem(av, mem))
		return (NULL);	//add free routine
	if (get_header_info(mem))
		return (NULL);	//add free routine
	if (fetch_save(mem))
		return (NULL);	//add free routine
	if (init_sdl(mem))
		return (NULL);	//add free routine
	defaults(mem);
	if (ac == 3 && !strcmp(av[2], "no_boot"))
		no_boot(mem);
	else
		get_boot(mem);
	return (mem);
}
